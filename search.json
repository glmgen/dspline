[{"path":"https://glmgen.github.io/dspline/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 dspline authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://glmgen.github.io/dspline/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Logan Brooks. Contributor. Addison Hu. Author. Daniel McDonald. Contributor. Ryan Tibshirani. Author, maintainer, copyright holder.","code":""},{"path":"https://glmgen.github.io/dspline/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hu , Tibshirani R (2025). dspline: Tools Computations Discrete Splines. R package version 1.0.2, https://github.com/glmgen/dspline.","code":"@Manual{,   title = {dspline: Tools for Computations with Discrete Splines},   author = {Addison Hu and Ryan Tibshirani},   year = {2025},   note = {R package version 1.0.2},   url = {https://github.com/glmgen/dspline}, }"},{"path":"https://glmgen.github.io/dspline/index.html","id":"dspline","dir":"","previous_headings":"","what":"Tools for Computations with Discrete Splines","title":"Tools for Computations with Discrete Splines","text":"B-splines:  called discrete B-splines. span function spaced called discrete splines, analogous splines, defined terms suitable discrete notion smoothness. Discrete splines continuous discrete derivatives knots (rather continuous derivatives, splines ). important computational properties, like fact interpolation within space discrete splines can done constant-time. intimately connected trend filtering (provide basis representation underlies trend filtering estimator). background, see monograph: “Divided differences, falling factorials, discrete splines: Another look trend filtering related problems”. dspline package provides tools computations discrete splines. core routines written C++ efficiency. See reference index summary tools available.","code":""},{"path":"https://glmgen.github.io/dspline/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for Computations with Discrete Splines","text":"can install development version dspline GitHub :","code":"# Install released version from CRAN install.packages(\"dspline\") # install.packages(\"pak\") pak::pak(\"glmgen/dspline\")"},{"path":"https://glmgen.github.io/dspline/reference/b_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct B matrix — b_mat","title":"Construct B matrix — b_mat","text":"Constructs extended discrete derivative matrix given order, respect given design points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/b_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct B matrix — b_mat","text":"","code":"b_mat(k, xd, tf_weighting = FALSE, row_idx = NULL)"},{"path":"https://glmgen.github.io/dspline/reference/b_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct B matrix — b_mat","text":"k Order extended discrete derivative matrix. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. tf_weighting \"trend filtering weighting\" used? weighting discrete derivatives implicit trend filtering; see details information. default FALSE. row_idx Vector indices, subset 1:n n = length(xd), indicates rows constructed matrix returned. default NULL, taken mean 1:n.","code":""},{"path":"https://glmgen.github.io/dspline/reference/b_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct B matrix — b_mat","text":"Sparse matrix dimension length(row_idx) length(xd).","code":""},{"path":"https://glmgen.github.io/dspline/reference/b_mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct B matrix — b_mat","text":"extended discrete derivative matrix order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(B^k_n\\). dimension \\(n \\times n\\), banded bandwidth \\(k+1\\). can constructed recursively, follows. \\(k \\geq 1\\), first define \\(n \\times n\\) extended difference matrix \\(\\bar{B}_{n,k}\\): $$   \\bar{B}_{n,k} =   \\left[\\begin{array}{rrrrrrrrr}   1 & 0 & \\ldots & 0 & & & & \\\\   0 & 1 & \\ldots & 0 & & & & \\\\   \\vdots & & & & & & & \\\\   0 & 0 & \\ldots & 1 & & & & \\\\   & & & -1 & 1 & 0 & \\ldots & 0 & 0 \\\\   & & & 0 & -1 & 1 & \\ldots & 0 & 0 \\\\   & & & \\vdots & & & & & \\\\   & & & 0 & 0 & 0 & \\ldots & -1 & 1   \\end{array}\\right]   \\begin{array}{ll}   \\left.\\vphantom{\\begin{array}{c} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{array}}   \\right\\} & \\hspace{-5pt} \\text{$k$ rows} \\\\   \\left.\\vphantom{\\begin{array}{c} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{array}}   \\right\\} & \\hspace{-5pt} \\text{$n-k$ rows}   \\end{array}.   $$ also define \\(n \\times n\\) extended diagonal weight matrix \\(Z^k_n\\) first \\(k\\) diagonal entries equal 1 last \\(n-k\\) diagonal entries equal \\((x_{+k} - x_i) / k\\), \\(=   1,\\ldots,n-k\\). \\(k\\)th order extended discrete derivative matrix \\(B^k_n\\) given recursion: $$   \\begin{aligned}   B^1_n &= (Z^1_n)^{-1} \\bar{B}_{n,1}, \\\\   B^k_n &= (Z^k_n)^{-1} \\bar{B}_{n,k} \\, B^{k-1}_n,   \\quad \\text{$k \\geq 2$}.   \\end{aligned}   $$ note discrete derivative matrix \\(D^k_n\\) d_mat() simply given last \\(n-k\\) rows extended matrix \\(B^k_n\\). option tf_weighting = TRUE returns \\(Z^k_n B^k_n\\) \\(Z^k_n\\) \\(n \\times n\\) diagonal matrix described . weighting implicit trend filtering, explained help file d_mat_mult(). See also Sections 6.1 6.2 Tibshirani (2020) discussion. Note: multiplication given vector \\(B^k_n\\), instead forming \\(B^k_n\\) current function carrying multiplication, one instead use b_mat_mult(), efficient (linear time, latter saves cost forming matrix first place).","code":""},{"path":"https://glmgen.github.io/dspline/reference/b_mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Construct B matrix — b_mat","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 6.2.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/b_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct B matrix — b_mat","text":"","code":"b_mat(2, 1:10) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                                    #>  [1,]  1  .  .  .  .  .  .  .  . . #>  [2,] -1  1  .  .  .  .  .  .  . . #>  [3,]  1 -2  1  .  .  .  .  .  . . #>  [4,]  .  1 -2  1  .  .  .  .  . . #>  [5,]  .  .  1 -2  1  .  .  .  . . #>  [6,]  .  .  .  1 -2  1  .  .  . . #>  [7,]  .  .  .  .  1 -2  1  .  . . #>  [8,]  .  .  .  .  .  1 -2  1  . . #>  [9,]  .  .  .  .  .  .  1 -2  1 . #> [10,]  .  .  .  .  .  .  .  1 -2 1 b_mat(2, 1:10 / 5) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                                             #>  [1,]  1   .   .   .   .   .   .   .   .  . #>  [2,] -5   5   .   .   .   .   .   .   .  . #>  [3,] 25 -50  25   .   .   .   .   .   .  . #>  [4,]  .  25 -50  25   .   .   .   .   .  . #>  [5,]  .   .  25 -50  25   .   .   .   .  . #>  [6,]  .   .   .  25 -50  25   .   .   .  . #>  [7,]  .   .   .   .  25 -50  25   .   .  . #>  [8,]  .   .   .   .   .  25 -50  25   .  . #>  [9,]  .   .   .   .   .   .  25 -50  25  . #> [10,]  .   .   .   .   .   .   .  25 -50 25 b_mat(2, 1:10 / 5, TRUE) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                                            #>  [1,]  1   .   .   .   .   .   .   .   . . #>  [2,] -5   5   .   .   .   .   .   .   . . #>  [3,]  5 -10   5   .   .   .   .   .   . . #>  [4,]  .   5 -10   5   .   .   .   .   . . #>  [5,]  .   .   5 -10   5   .   .   .   . . #>  [6,]  .   .   .   5 -10   5   .   .   . . #>  [7,]  .   .   .   .   5 -10   5   .   . . #>  [8,]  .   .   .   .   .   5 -10   5   . . #>  [9,]  .   .   .   .   .   .   5 -10   5 . #> [10,]  .   .   .   .   .   .   .   5 -10 5 b_mat(2, 1:10, row_idx = 2:5) #> 4 x 10 sparse Matrix of class \"dgCMatrix\" #>                              #> [1,] -1  1  .  . . . . . . . #> [2,]  1 -2  1  . . . . . . . #> [3,]  .  1 -2  1 . . . . . . #> [4,]  .  .  1 -2 1 . . . . ."},{"path":"https://glmgen.github.io/dspline/reference/b_mat_mult.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiply by B matrix — b_mat_mult","title":"Multiply by B matrix — b_mat_mult","text":"Multiplies given vector B, extended discrete derivative matrix given order, respect given design points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/b_mat_mult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiply by B matrix — b_mat_mult","text":"","code":"b_mat_mult(v, k, xd, tf_weighting = FALSE, transpose = FALSE, inverse = FALSE)"},{"path":"https://glmgen.github.io/dspline/reference/b_mat_mult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiply by B matrix — b_mat_mult","text":"v Vector multiplied B, extended discrete derivative matrix. k Order extended discrete derivative matrix. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. tf_weighting \"trend filtering weighting\" used? weighting discrete derivatives implicit trend filtering; see details information. default FALSE. transpose Multiply transpose B? default FALSE. inverse Multiply inverse B? default FALSE.","code":""},{"path":"https://glmgen.github.io/dspline/reference/b_mat_mult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiply by B matrix — b_mat_mult","text":"Product extended discrete derivative matrix B input vector v.","code":""},{"path":"https://glmgen.github.io/dspline/reference/b_mat_mult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multiply by B matrix — b_mat_mult","text":"extended discrete derivative matrix order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(B^k_n\\). square, dimension \\(n \\times n\\). Acting vector \\(v\\) function evaluations design points, denoted \\(v   = f(x_{1:n})\\), gives discrete derivatives \\(f\\) points \\(x_{1:n}\\): $$   B^k_n v = (\\Delta^k_n f) (x_{1:n}).   $$ matrix \\(B^k_n\\) can constructed recursively product diagonally-weighted first difference matrix \\(B^{k-1}_n\\); see help file b_mat(), Section 6.2 Tibshirani (2020). Therefore, multiplication \\(B^k_n\\) transpose can performed \\(O(nk)\\) operations based iterated weighted differences. See Appendix D Tibshirani (2020) details. option tf_weighting = TRUE performs multiplication \\(Z^k_n B^k_n\\) \\(Z^k_n\\) \\(n \\times n\\) diagonal matrix whose top left \\(k \\times k\\) block equals identity matrix bottom right \\((n-k) \\times (n-k)\\) block equals \\(W^k_n\\), latter diagonal weight matrix implicit trend filtering, explained help file d_mat_mult(). Lastly, matrix \\(B^k_n\\) special inverse relationship falling factorial basis matrix \\(H^{k-1}_n\\) degree \\(k-1\\) knots \\(x_{k:(n-1)}\\); satisfies: $$   Z^k_n B^k_n H^{k-1}_n = I_n,   $$ \\(Z^k_n\\) \\(n \\times n\\) diagonal matrix described , \\(I_n\\) \\(n \\times n\\) identity matrix. , combined fact falling factorial basis matrix efficient recursive representation terms weighted cumulative sums, means multiplying \\((B^k_n)^{-1}\\) transpose can performed \\(O(nk)\\) operations. See Section 6.3 Appendix D Tibshirani (2020) details.","code":""},{"path":"https://glmgen.github.io/dspline/reference/b_mat_mult.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multiply by B matrix — b_mat_mult","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 6.2.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/b_mat_mult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiply by B matrix — b_mat_mult","text":"","code":"v <- sort(runif(10)) as.vector(b_mat(2, 1:10) %*% v) #>  [1]  0.007399441  0.073350696  0.003107608  0.056100499  0.044067450 #>  [6] -0.145242361  0.071599606  0.029137603 -0.092481577  0.022172002 b_mat_mult(v, 2, 1:10) # more efficient #>  [1]  0.007399441  0.073350696  0.003107608  0.056100499  0.044067450 #>  [6] -0.145242361  0.071599606  0.029137603 -0.092481577  0.022172002"},{"path":"https://glmgen.github.io/dspline/reference/d_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct D matrix — d_mat","title":"Construct D matrix — d_mat","text":"Constructs discrete derivative matrix given order, respect given design points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/d_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct D matrix — d_mat","text":"","code":"d_mat(k, xd, tf_weighting = FALSE, row_idx = NULL)"},{"path":"https://glmgen.github.io/dspline/reference/d_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct D matrix — d_mat","text":"k Order discrete derivative matrix. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. tf_weighting \"trend filtering weighting\" used? weighting discrete derivatives implicit trend filtering; see details information. default FALSE. row_idx Vector indices, subset 1:(n-k) n = length(xd), indicates rows constructed matrix returned. default NULL, taken mean 1:(n-k).","code":""},{"path":"https://glmgen.github.io/dspline/reference/d_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct D matrix — d_mat","text":"Sparse matrix dimension length(row_idx) length(xd).","code":""},{"path":"https://glmgen.github.io/dspline/reference/d_mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct D matrix — d_mat","text":"discrete derivative matrix order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(D^k_n\\). dimension \\((n-k) \\times n\\), banded bandwidth \\(k+1\\). can constructed recursively, follows. first define \\((n-1)   \\times n\\) first difference matrix \\(\\bar{D}_n\\): $$   \\bar{D}_n =   \\left[\\begin{array}{rrrrrr}   -1 & 1 & 0 & \\ldots & 0 & 0 \\\\   0 & -1 & 1 & \\ldots & 0 & 0 \\\\   \\vdots & & & & & \\\\   0 & 0 & 0 & \\ldots & -1 & 1   \\end{array}\\right],   $$ \\(k \\geq 1\\), define \\((n-k) \\times (n-k)\\) diagonal weight matrix \\(W^k_n\\) diagonal entries \\((x_{+k} - x_i) / k\\), \\(= 1,\\ldots,n-k\\). \\(k\\)th order discrete derivative matrix \\(D^k_n\\) given recursion: $$   \\begin{aligned}   D^1_n &= (W^1_n)^{-1} \\bar{D}_n, \\\\   D^k_n &= (W^k_n)^{-1} \\bar{D}_{n-k+1} \\, D^{k-1}_n,   \\quad \\text{$k \\geq 2$}.   \\end{aligned}   $$ note \\(\\bar{D}_{n-k+1}\\) denotes \\((n-k) \\times   (n-k+1)\\) version first difference matrix defined second--last display. option tf_weighting = TRUE returns \\(W^k_n D^k_n\\) \\(W^k_n\\) \\((n-k) \\times (n-k)\\) diagonal matrix described . weighting implicit trend filtering, explained help file d_mat_mult(). See also Section 6.1 Tibshirani (2020) discussion. Note: multiplication given vector \\(D^k_n\\), instead forming \\(D^k_n\\) current function carrying multiplication, one instead use d_mat_mult(), efficient (linear time, latter saves cost forming matrix first place).","code":""},{"path":"https://glmgen.github.io/dspline/reference/d_mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Construct D matrix — d_mat","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 6.1.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/d_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct D matrix — d_mat","text":"","code":"d_mat(2, 1:10) #> 8 x 10 sparse Matrix of class \"dgCMatrix\" #>                                  #> [1,] 1 -2  1  .  .  .  .  .  . . #> [2,] .  1 -2  1  .  .  .  .  . . #> [3,] .  .  1 -2  1  .  .  .  . . #> [4,] .  .  .  1 -2  1  .  .  . . #> [5,] .  .  .  .  1 -2  1  .  . . #> [6,] .  .  .  .  .  1 -2  1  . . #> [7,] .  .  .  .  .  .  1 -2  1 . #> [8,] .  .  .  .  .  .  .  1 -2 1 d_mat(2, 1:10 / 5) #> 8 x 10 sparse Matrix of class \"dgCMatrix\" #>                                            #> [1,] 25 -50  25   .   .   .   .   .   .  . #> [2,]  .  25 -50  25   .   .   .   .   .  . #> [3,]  .   .  25 -50  25   .   .   .   .  . #> [4,]  .   .   .  25 -50  25   .   .   .  . #> [5,]  .   .   .   .  25 -50  25   .   .  . #> [6,]  .   .   .   .   .  25 -50  25   .  . #> [7,]  .   .   .   .   .   .  25 -50  25  . #> [8,]  .   .   .   .   .   .   .  25 -50 25 d_mat(2, 1:10 / 5, TRUE) #> 8 x 10 sparse Matrix of class \"dgCMatrix\" #>                                          #> [1,] 5 -10   5   .   .   .   .   .   . . #> [2,] .   5 -10   5   .   .   .   .   . . #> [3,] .   .   5 -10   5   .   .   .   . . #> [4,] .   .   .   5 -10   5   .   .   . . #> [5,] .   .   .   .   5 -10   5   .   . . #> [6,] .   .   .   .   .   5 -10   5   . . #> [7,] .   .   .   .   .   .   5 -10   5 . #> [8,] .   .   .   .   .   .   .   5 -10 5 d_mat(2, 1:10, row_idx = 2:5) #> 4 x 10 sparse Matrix of class \"dgCMatrix\" #>                              #> [1,] . 1 -2  1  .  . . . . . #> [2,] . .  1 -2  1  . . . . . #> [3,] . .  .  1 -2  1 . . . . #> [4,] . .  .  .  1 -2 1 . . ."},{"path":"https://glmgen.github.io/dspline/reference/d_mat_mult.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiply by D matrix — d_mat_mult","title":"Multiply by D matrix — d_mat_mult","text":"Multiplies given vector D, discrete derivative matrix given order, respect given design points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/d_mat_mult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiply by D matrix — d_mat_mult","text":"","code":"d_mat_mult(v, k, xd, tf_weighting = FALSE, transpose = FALSE)"},{"path":"https://glmgen.github.io/dspline/reference/d_mat_mult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiply by D matrix — d_mat_mult","text":"v Vector multiplied D, discrete derivative matrix. k Order discrete derivative matrix. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. tf_weighting \"trend filtering weighting\" used? weighting discrete derivatives implicit trend filtering; see details information. default FALSE. transpose Multiply transpose D? default FALSE.","code":""},{"path":"https://glmgen.github.io/dspline/reference/d_mat_mult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiply by D matrix — d_mat_mult","text":"Product discrete derivative matrix D input vector v.","code":""},{"path":"https://glmgen.github.io/dspline/reference/d_mat_mult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multiply by D matrix — d_mat_mult","text":"discrete derivative matrix order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(D^k_n\\). dimension \\((n-k) \\times n\\). Acting vector \\(v\\) function evaluations design points, denoted \\(v = f(x_{1:n})\\), gives discrete derivatives \\(f\\) points \\(x_{(k+1):n}\\): $$   D^k_n v = (\\Delta^k_n f) (x_{(k+1):n}).   $$ matrix \\(D^k_n\\) can constructed recursively product diagonally-weighted first difference matrix \\(D^{k-1}_n\\); see help file d_mat(), Section 6.1 Tibshirani (2020). Therefore, multiplication \\(D^k_n\\) transpose can performed \\(O(nk)\\) operations based iterated weighted differences. See Appendix D Tibshirani (2020) details. option tf_weighting = TRUE performs multiplication \\(W^k_n D^k_n\\) \\(W^k_n\\) \\((n-k) \\times (n-k)\\) diagonal matrix entries \\((x_{+k} - x_i) / k\\), \\(= 1,\\ldots,n-k\\). weighting implicit trend filtering, penalty \\(k\\)th order trend filtering optimization problem (optimization parameter \\(\\theta\\)) \\(\\|W^{k+1}_n D^{k+1}_n \\theta\\|_1\\). Moreover, precisely \\(k\\)th order total variation \\(k\\)th degree discrete spline interpolant \\(f\\) \\(\\theta\\), knots \\(x_{(k+1):(n-1)}\\); , interpolant satisfies: $$   \\mathrm{TV}(D^k f) = \\|W^{k+1}_n D^{k+1}_n \\theta\\|_1,   $$ \\(D^k f\\) \\(k\\)th derivative \\(f\\). See Section 9.1. Tibshirani (2020) details.","code":""},{"path":"https://glmgen.github.io/dspline/reference/d_mat_mult.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multiply by D matrix — d_mat_mult","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 6.1.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/d_mat_mult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiply by D matrix — d_mat_mult","text":"","code":"v <- sort(runif(10)) as.vector(d_mat(2, 1:10) %*% v) #> [1]  0.08185904 -0.09054996  0.10398669 -0.05640031 -0.05468866 -0.01241705 #> [7]  0.46985266 -0.37011537 d_mat_mult(v, 2, 1:10) # more efficient #> [1]  0.08185904 -0.09054996  0.10398669 -0.05640031 -0.05468866 -0.01241705 #> [7]  0.46985266 -0.37011537"},{"path":"https://glmgen.github.io/dspline/reference/discrete_deriv.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete differentiation — discrete_deriv","title":"Discrete differentiation — discrete_deriv","text":"Computes discrete derivative function (vector function evaluations) given order, respect given design points, evaluated given query point.","code":""},{"path":"https://glmgen.github.io/dspline/reference/discrete_deriv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete differentiation — discrete_deriv","text":"","code":"discrete_deriv(f, k, xd, x)"},{"path":"https://glmgen.github.io/dspline/reference/discrete_deriv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete differentiation — discrete_deriv","text":"f Function, vector function evaluations c(xd, x), design points xd adjoined query point(s) x. k Order discrete derivative calculation. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. x Query point(s).","code":""},{"path":"https://glmgen.github.io/dspline/reference/discrete_deriv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete differentiation — discrete_deriv","text":"Discrete derivative f order k, respect design points xd, evaluated query point(s) x.","code":""},{"path":"https://glmgen.github.io/dspline/reference/discrete_deriv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discrete differentiation — discrete_deriv","text":"discrete derivative operator order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(\\Delta^k_n\\). Acting function \\(f\\), evaluated query point \\(x\\), yields: $$   (\\Delta^k_n f) (x) =   \\begin{cases}   k! \\cdot f[x_{-k+1},\\ldots,x_i,x] & \\text{$x \\(x_i,x_{+1}]$, $  \\geq k$} \\\\   ! \\cdot f[x_1,\\ldots,x_i,x] & \\text{$x \\(x_i,x_{+1}]$, $< k$} \\\\   f(x) & \\text{$x \\leq x_1$},   \\end{cases}   $$ take \\(x_{n+1} = \\infty\\) convenience. words, \"\" points \\(x > x_k\\), define \\((\\Delta^k_n f)(x)\\) terms (scaled) divided difference \\(f\\) order \\(k\\), centers \\(k\\) points immediately left \\(x\\), \\(x\\) . Meanwhile, \"boundary\" points \\(x \\leq x_k\\), define \\((\\Delta^k_n f)(x)\\) (scaled) divided difference \\(f\\) highest possible order, centers points left \\(x\\), \\(x\\) . discussion, including alternative representations discrete differentiation, see Section 3.1 Tibshirani (2020). Note: calculating discrete derivatives design points , achieved taking x = xd current function, one instead use b_mat_mult() d_mat_mult(), efficient (linear-time, latter functions faster).","code":""},{"path":"https://glmgen.github.io/dspline/reference/discrete_deriv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Discrete differentiation — discrete_deriv","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 3.1.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/discrete_deriv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete differentiation — discrete_deriv","text":"","code":"xd <- 1:9 discrete_deriv(sin, 2, xd, 1:8 + 0.5) #> [1]  0.3120480 -0.9193027 -0.2875054  0.6086230  0.9451862  0.4127496 -0.4991671 #> [8] -0.9521519 discrete_deriv(cos, 2, xd, 1:8 + 0.5) #> [1] -0.93913021  0.24860745  0.90788970  0.73246236 -0.11638750 -0.85823123 #> [7] -0.81102112 -0.01816193 discrete_deriv(function(x) (x + 2)^2, 2, -5:5, c(-2.5, 2.5)) #> [1] 2 2"},{"path":"https://glmgen.github.io/dspline/reference/discrete_integ.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete integration — discrete_integ","title":"Discrete integration — discrete_integ","text":"Computes discrete integral function (vector function evaluations) given order, respect given design points, evaluated given query point.","code":""},{"path":"https://glmgen.github.io/dspline/reference/discrete_integ.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete integration — discrete_integ","text":"","code":"discrete_integ(f, k, xd, x)"},{"path":"https://glmgen.github.io/dspline/reference/discrete_integ.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete integration — discrete_integ","text":"f Function, vector function evaluations c(xd, x), design points xd adjoined query point(s) x. k Order discrete integral calculation. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. x Query point(s).","code":""},{"path":"https://glmgen.github.io/dspline/reference/discrete_integ.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete integration — discrete_integ","text":"Discrete integral f order k, respect design points xd, evaluated query point(s) x.","code":""},{"path":"https://glmgen.github.io/dspline/reference/discrete_integ.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discrete integration — discrete_integ","text":"discrete integral operator order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(S^k_n\\). inverse operator discrete derivative operator \\(\\Delta^k_n\\), : $$   S^k_n \\Delta^k_n = \\Delta^k_n S^k_n = \\mathrm{Id},   $$ \\(\\mathrm{Id}\\) denotes identity operator. can also represented explicit form, follows. Acting function \\(f\\) order \\(k\\), evaluated query point \\(x\\), yields: $$   (S^k_n f)(x) =   \\begin{cases}   \\displaystyle   \\sum_{j=1}^k h^{k-1}_j(x) \\cdot f(x_j) +   \\sum_{j=k+1}^h^{k-1}_j(x) \\cdot \\frac{x_j-x_{j-k}}{k} \\cdot f(x_j)   + h^{k-1}_{+1}(x) \\cdot \\frac{x-x_{-k+1}}{k} \\cdot f(x) & \\\\   & \\hspace{-75pt} \\text{$x \\(x_i,x_{+1}]$, $\\geq k$} \\\\   \\displaystyle   \\sum_{j=1}^h^{k-1}_j(x) \\cdot f(x_j) \\,+\\, h^{k-1}_{+1}(x) \\cdot f(x)   & \\hspace{-75pt} \\text{$x \\(x_i,x_{+1}]$, $<  k$} \\\\   f(x) & \\hspace{-75pt} \\text{$x \\leq x_1$},   \\end{cases}   $$ \\(h^{k-1}_1, \\ldots, h^{k-1}_n\\) denote falling factorial basis functions degree \\(k-1\\), knots \\(x_{k:(n-1)}\\). help file h_mat() gives definition falling factorial basis. can seen (due one-sided support falling factorial basis functions) discrete integration \\(x = x_i\\), \\(= 1,\\ldots,n\\) equivalent multiplication weighted version falling factorial basis matrix. details, including alternative recursive representation discrete integration (elucidates relationship discrete differentiation), see Section 3.2 Tibshirani (2020). Note: calculating discrete integrals design points , achieved taking x = xd current function, one instead use h_mat_mult() di_weighting = TRUE, much efficient (quadratic-time versus linear-time).","code":""},{"path":"https://glmgen.github.io/dspline/reference/discrete_integ.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Discrete integration — discrete_integ","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 3.2.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/discrete_integ.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete integration — discrete_integ","text":"","code":"xd <- 1:9 discrete_integ(sin, 2, xd, 1:8 + 0.5) #> [1] 1.340218 2.429844 3.194851 2.875034 1.832259 1.093074 1.404909 2.548891 discrete_integ(cos, 2, xd, 1:8 + 0.5) #> [1]  0.5756709 -0.3843468 -2.3362248 -4.4507067 -5.7401968 -5.9755929 -5.8969222 #> [8] -6.5329632 discrete_integ(function(x) (x + 2)^2, 2, -5:5, c(-2.5, 2.5)) #> [1]  20.59375 118.09375"},{"path":"https://glmgen.github.io/dspline/reference/divided_diff.html","id":null,"dir":"Reference","previous_headings":"","what":"Divided differencing — divided_diff","title":"Divided differencing — divided_diff","text":"Computes divided difference function (vector function evaluations) respect given centers.","code":""},{"path":"https://glmgen.github.io/dspline/reference/divided_diff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divided differencing — divided_diff","text":"","code":"divided_diff(f, z)"},{"path":"https://glmgen.github.io/dspline/reference/divided_diff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divided differencing — divided_diff","text":"f Function, vector function evaluations centers. z Centers divided difference calculation.","code":""},{"path":"https://glmgen.github.io/dspline/reference/divided_diff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divided differencing — divided_diff","text":"Divided difference f respect centers z.","code":""},{"path":"https://glmgen.github.io/dspline/reference/divided_diff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Divided differencing — divided_diff","text":"divided difference function \\(f\\) respect centers \\(z_1, \\ldots, z_{k+1}\\) defined recursively : $$   f[z_1,\\ldots,z_{k+1}] = \\displaystyle   \\frac{f[z_2,\\ldots,z_{k+1}] - f[z_1,\\ldots,z_k]}{z_{k+1}-z_1},   $$ base case \\(f[z_1] = f(z_1)\\) (, divided differencing respect single point reduces function evaluation). notable special case centers evenly-spaced, say, \\(z_i =   z+ih\\), \\(=0,\\ldots,k\\) spacing \\(h>0\\), case divided difference becomes (scaled) forward difference, equivalently (scaled) backward difference, $$   k! \\cdot f[z,\\ldots,z+kh] = \\displaystyle   \\frac{1}{h^k} (F^k_h f)(z) =   \\frac{1}{h^k} (B^k_h f)(z+kh),   $$ use \\(F^k_h\\) \\(B^k_v\\) denote forward backward difference operators, respectively, order \\(k\\) spacing \\(h\\).","code":""},{"path":"https://glmgen.github.io/dspline/reference/divided_diff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divided differencing — divided_diff","text":"","code":"divided_diff(sin, 1:99 / 100 * 2 * pi) #> [1] -7.542996e-25 divided_diff(cos, 1:99 / 100 * 2 * pi) #> [1] 6.442465e-26 divided_diff(function(x) (x + 2)^2, seq(-5, 5, length.out = 100)) #> [1] -5.694125e-45"},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"In-place computations — dot_functions","title":"In-place computations — dot_functions","text":"\"dot\" function accepts arguments \"non-dot\" counterpart, peforms computations place, overwriting first input argument (must vector appropriate length) desired output.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"In-place computations — dot_functions","text":"","code":".divided_diff(f, z)  .b_mat_mult(v, k, xd, tf_weighting, transpose, inverse)  .h_mat_mult(v, k, xd, di_weighting, transpose, inverse)"},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"In-place computations — dot_functions","text":"f Function, vector function evaluations centers. z Centers divided difference calculation. v Vector multiplied B, extended discrete derivative matrix. k Order extended discrete derivative matrix. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. tf_weighting \"trend filtering weighting\" used? weighting discrete derivatives implicit trend filtering; see details information. default FALSE. transpose Multiply transpose B? default FALSE. inverse Multiply inverse B? default FALSE. di_weighting \"discrete integration weighting\" used? Multiplication weighted H gives discrete integrals design points; see details information. default FALSE.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"In-place computations — dot_functions","text":"None. functions overwrite input.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"In-place computations — dot_functions","text":"functions used unless intentionally memory considerations nonetheless careful. important warning: \"dot\" function works expected first argument passed vector numeric type. first argument passed integer vector, since output must (general) numeric vector, computed place (Rcpp performs implicit cast copy converts NumericVector type use C++). Also, \"dot\" function perform error checking input arguments. Use care. details computations performed individual functions provided .","code":""},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":"-divided-diff-","dir":"Reference","previous_headings":"","what":".divided_diff()","title":"In-place computations — dot_functions","text":"Overwrites f lower-order divided differences: element f[] becomes divided difference respect centers z[1:]. See also divided_diff().","code":""},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":"-b-mat-mult-","dir":"Reference","previous_headings":"","what":".b_mat_mult()","title":"In-place computations — dot_functions","text":"Overwrites v B %*% v, B extended discrete derivative matrix returned b_mat(). See also b_mat_mult().","code":""},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":"-h-mat-mult-","dir":"Reference","previous_headings":"","what":".h_mat_mult()","title":"In-place computations — dot_functions","text":"Overwrites v H %*% v, H falling factorial basis matrix returned h_mat(). See also h_mat_mult().","code":""},{"path":"https://glmgen.github.io/dspline/reference/dot_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"In-place computations — dot_functions","text":"","code":"v <- sort(runif(10)) v #>  [1] 0.05144628 0.19595673 0.28989230 0.53021246 0.67838043 0.68855600 #>  [7] 0.69582388 0.73531960 0.74152153 0.98053967 b_mat_mult(v, 2, 1:10) #>  [1]  0.05144628  0.14451046 -0.05057489  0.14638461 -0.09215220 -0.13799239 #>  [7] -0.00290770  0.03222784 -0.03329379  0.23281622 .b_mat_mult(v, 2, 1:10, FALSE, FALSE, FALSE) v #>  [1]  0.05144628  0.14451046 -0.05057489  0.14638461 -0.09215220 -0.13799239 #>  [7] -0.00290770  0.03222784 -0.03329379  0.23281622"},{"path":"https://glmgen.github.io/dspline/reference/dspline-package.html","id":null,"dir":"Reference","previous_headings":"","what":"dspline: Tools for Computations with Discrete Splines — dspline-package","title":"dspline: Tools for Computations with Discrete Splines — dspline-package","text":"Discrete splines class univariate piecewise polynomial functions close connections divided differences Newton interpolation. Tools efficient computations relating discrete splines provided . tools include discrete differentiation integration, various matrix computations discrete derivative discrete spline bases matrices, interpolation within discrete spline spaces. Many techniques described Tibshirani (2020) arXiv:2003.03886.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/dspline-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"dspline: Tools for Computations with Discrete Splines — dspline-package","text":"Maintainer: Ryan Tibshirani ryantibs@gmail.com [copyright holder] Authors: Addison Hu contributors: Logan Brooks [contributor]","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_interp.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete spline interpolation — dspline_interp","title":"Discrete spline interpolation — dspline_interp","text":"Interpolates sequence values within \"canonical\" space discrete splines given order, respect given design points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_interp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete spline interpolation — dspline_interp","text":"","code":"dspline_interp(v, k, xd, x, implicit = TRUE)"},{"path":"https://glmgen.github.io/dspline/reference/dspline_interp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete spline interpolation — dspline_interp","text":"v Vector values interpolated, one value per design point. k Order discrete spline space. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. x Query point(s), perform interpolation. implicit implicit form interpolation used? See details means. default TRUE.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_interp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete spline interpolation — dspline_interp","text":"Value(s) unique discrete spline interpolant (defined values v design points xd) query point(s) x.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_interp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discrete spline interpolation — dspline_interp","text":"\"canonical\" space discrete splines degree \\(k\\), respect design points \\(x_{1:n}\\), spanned falling factorial basis functions \\(h^k_1, \\ldots, h^k_n\\), defined : $$   \\begin{aligned}   h^k_j(x) &= \\frac{1}{(j-1)!} \\prod_{\\ell=1}^{j-1}(x-x_\\ell),   \\quad j=1,\\ldots,k+1, \\\\   h^k_j(x) &= \\frac{1}{k!} \\prod_{\\ell=j-k}^{j-1} (x-x_\\ell) \\cdot   1\\{x > x_{j-1}\\}, \\quad j=k+2,\\ldots,n.   \\end{aligned}   $$ span space piecewise polynomials degree \\(k\\) knots \\(x_{(k+1):(n-1)}\\)—fact, just piecewise polynomials, special ones continuous discrete derivatives (defined terms divided differences; see help file discrete_deriv() definition) orders \\(0, \\ldots, k-1\\) knot points. precisely analogous splines derivatives replaced discrete derivatves, hence name discrete splines. See Section 4.1 Tibshirani (2020) details. space discrete splines degree \\(k\\) knots \\(x_{(k+1):(n-1)}\\) linear dimension \\(n\\), sequence \\(n\\) values (one design points \\(x_{1:n}\\)) unique discrete spline interpolant. Evaluating interpolant query point \\(x\\) can done via falling factorial basis expansion, coefficients expansion can computed efficiently (\\(O(nk)\\) operations) due fact inverse falling factorial basis matrix can represented terms extended discrete derivatives (see help file h_mat_mult() details). implicit = FALSE, interpolation carried described paragraph. worth noting strict generalization Newton's divided difference interpolation, given special case \\(n = k+1\\) (case knot set empty, \"canonical\" space degree \\(k\\) discrete splines nothing space degree \\(k\\) polynomials). See Section 5.3 Tibshirani (2020) details. implicit = TRUE, implicit form used evaluate interpolant arbitrary query point \\(x\\), locates \\(x\\) among design points \\(x_{1:n}\\) (\\(O(\\log n)\\) computational cost), solves value \\(f(x)\\) results local order \\(k+1\\) discrete derivative equal zero (\\(O(k)\\) computational cost). generally efficient stable scheme interpolation. See Section 5.4 Tibshirani (2020) details.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_interp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Discrete spline interpolation — dspline_interp","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 5.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/dspline_interp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete spline interpolation — dspline_interp","text":"","code":"xd <- 1:99 / 100 v <- sin(2 * pi * xd) + rnorm(99, 0, .2) res <- dspline_solve(v, 2, xd, 1:9 * 10) plot(xd, v, pch = 16) x <- 1:98 / 100 + 0.005 # locations in between `xd` vhat <- dspline_interp(res$fit, 2, xd, x) points(x, vhat, col = \"firebrick\")"},{"path":"https://glmgen.github.io/dspline/reference/dspline_solve.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete spline projection — dspline_solve","title":"Discrete spline projection — dspline_solve","text":"Projects sequence values onto space discrete splines given order, respect given design points, given knot points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_solve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete spline projection — dspline_solve","text":"","code":"dspline_solve(v, k, xd, knot_idx, basis = c(\"N\", \"B\", \"H\"), mat)"},{"path":"https://glmgen.github.io/dspline/reference/dspline_solve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete spline projection — dspline_solve","text":"v Vector values projected, one value per design point. k Order discrete spline space. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. knot_idx Vector indices, subset (k+1):(n-1) n = length(xd), indicates design points used knot points discrete spline space. Must sorted increasing order. basis String, one \"N\", \"B\", \"H\", indicating basis representation used least squares computation. default \"N\", discrete B-spline basis. See details information. mat Matrix use least squares computation. missing, default, matrix formed according basis argument. See details information.","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_solve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete spline projection — dspline_solve","text":"List components sol: least squares solution; fit: least squares fit; mat: basis matrix used least squares problem (present input argument mat missing).","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_solve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discrete spline projection — dspline_solve","text":"function minimizes least squares criterion $$   \\|v - M \\beta\\|_2^2   $$ coefficient vectors \\(\\beta\\); , computes $$   \\hat\\beta = (M^T M)^{-1} M^T v   $$ vector \\(v\\) basis matrix \\(M\\). basis matrix \\(M\\) specified via basis argument, allows three options. default \"N\", case discrete B-spline basis matrix n_mat() used, knot_idx argument set accordingly. generally stable efficient option: leads banded, well-conditioned linear system.  Bandedness means least squares projection can computed \\(O(nk^2)\\) operations. See Section 8.4 Tibshirani (2020) numerical experiments investigating conditioning. option \"H\" means falling factorial basis matrix h_mat() used, col_idx argument set appropriately. option avoided general since leads linear system neither sparse well-conditioned. option \"B\" means extended discrete derivative matrix b_mat(), tf_weighting = TRUE, used compute least squares solution projecting onto falling factorial basis. fact possible stems special inverse relationship discrete derivative matrix falling factorial basis matrix. option leads banded linear system, system tends worse conditioning using discrete B-spline representation. However, essentially always preferable \"H\" option, produces solution (coefficients falling factorial basis expansion). Note 1: basis matrix used least squares problem can passed directly via mat argument (saves cost computing first place). Even mat missing, basis argument must still used specify type basis matrix passed , downstream computations differ depending type. Note 2: mat missing basis = \"B\", matrix passed must entire extended discrete derivative matrix, returned b_mat() row_idx = NULL (default), row-subsetted version. rows corresponding knots discrete spline space complementary set roles play role computing solution. See Section 8.1 Tibshirani (2020).","code":""},{"path":"https://glmgen.github.io/dspline/reference/dspline_solve.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Discrete spline projection — dspline_solve","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Sections 8.1 8.4.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/dspline_solve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete spline projection — dspline_solve","text":"","code":"xd <- 1:99 / 100 v <- sin(2 * pi * xd) + rnorm(99, 0, .2) res <- dspline_solve(v, 2, xd, 1:9 * 10) plot(xd, v, pch = 16) lines(xd, res$fit, col = \"cornflowerblue\") lines(xd, sin(2 * pi * xd), col = \"firebrick\")"},{"path":"https://glmgen.github.io/dspline/reference/h_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate H basis — h_eval","title":"Evaluate H basis — h_eval","text":"Evaluates falling factorial basis given order, respect given design points, arbitrary query points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate H basis — h_eval","text":"","code":"h_eval(k, xd, x, col_idx = NULL)"},{"path":"https://glmgen.github.io/dspline/reference/h_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate H basis — h_eval","text":"k Order falling factorial basis. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. x Query points. Must sorted increasing order. col_idx Vector indices, subset 1:n n = length(xd), indicates columns constructed matrix returned. default NULL, taken mean 1:n.","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate H basis — h_eval","text":"Sparse matrix dimension length(x) length(col_idx).","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_eval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate H basis — h_eval","text":"falling factorial basis functions order \\(k\\), defined respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(h^k_1,   \\ldots, h^k_n\\). precise definition references, see help file h_mat(). current function produces matrix evaluations falling factorial basis arbitrary sequence query points. query point \\(x\\), matrix corresponding row entries: $$   h^k_j(x), \\; j = 1, \\ldots, n.   $$","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/h_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate H basis — h_eval","text":"","code":"xd <- 1:9 / 10 x <- 1:8 / 10 + 0.05 h_mat(2, xd) #> 9 x 9 sparse Matrix of class \"dgCMatrix\" #>                                                #>  [1,] 1 .   .    .    .    .    .    .    .    #>  [2,] 1 0.1 .    .    .    .    .    .    .    #>  [3,] 1 0.2 0.01 .    .    .    .    .    .    #>  [4,] 1 0.3 0.03 0.01 .    .    .    .    .    #>  [5,] 1 0.4 0.06 0.03 0.01 .    .    .    .    #>  [6,] 1 0.5 0.10 0.06 0.03 0.01 .    .    .    #>  [7,] 1 0.6 0.15 0.10 0.06 0.03 0.01 .    .    #>  [8,] 1 0.7 0.21 0.15 0.10 0.06 0.03 0.01 .    #>  [9,] 1 0.8 0.28 0.21 0.15 0.10 0.06 0.03 0.01 h_eval(2, xd, x) #> 8 x 9 sparse Matrix of class \"dgCMatrix\" #>                                                                      #> [1,] 1 0.05 -0.00125 .       .       .       .       .       .       #> [2,] 1 0.15  0.00375 .       .       .       .       .       .       #> [3,] 1 0.25  0.01875 0.00375 .       .       .       .       .       #> [4,] 1 0.35  0.04375 0.01875 0.00375 .       .       .       .       #> [5,] 1 0.45  0.07875 0.04375 0.01875 0.00375 .       .       .       #> [6,] 1 0.55  0.12375 0.07875 0.04375 0.01875 0.00375 .       .       #> [7,] 1 0.65  0.17875 0.12375 0.07875 0.04375 0.01875 0.00375 .       #> [8,] 1 0.75  0.24375 0.17875 0.12375 0.07875 0.04375 0.01875 0.00375"},{"path":"https://glmgen.github.io/dspline/reference/h_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct H matrix — h_mat","title":"Construct H matrix — h_mat","text":"Constructs falling factorial basis matrix given order, respect given design points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct H matrix — h_mat","text":"","code":"h_mat(k, xd, di_weighting = FALSE, col_idx = NULL)"},{"path":"https://glmgen.github.io/dspline/reference/h_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct H matrix — h_mat","text":"k Order falling factorial basis matrix. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. di_weighting \"discrete integration weighting\" used? Multiplication weighted H gives discrete integrals design points; see details information. default FALSE. col_idx Vector indices, subset 1:n n = length(xd), indicates columns constructed matrix returned. default NULL, taken mean 1:n.","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct H matrix — h_mat","text":"Sparse matrix dimension length(xd) length(col_idx).","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct H matrix — h_mat","text":"falling factorial basis matrix order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(H^k_n\\). dimension \\(n \\times n\\), entries defined : $$   (H^k_n)_{ij} = h^k_j(x_i),   $$ \\(h^k_1, \\ldots, h^k_n\\) falling factorial basis functions, defined : $$   \\begin{aligned}   h^k_j(x) &= \\frac{1}{(j-1)!} \\prod_{\\ell=1}^{j-1}(x-x_\\ell),   \\quad j=1,\\ldots,k+1, \\\\   h^k_j(x) &= \\frac{1}{k!} \\prod_{\\ell=j-k}^{j-1} (x-x_\\ell) \\cdot   1\\{x > x_{j-1}\\}, \\quad j=k+2,\\ldots,n.   \\end{aligned}   $$ matrix \\(H^k_n\\) can also constructed recursively, follows. first define \\(n \\times n\\) lower triangular matrix 1s: $$   L_n =   \\left[\\begin{array}{rrrr}   1 & 0 & \\ldots & 0 \\\\   1 & 1 & \\ldots & 0 \\\\   \\vdots & & & \\\\   1 & 1 & \\ldots & 1   \\end{array}\\right],   $$ \\(k \\geq 1\\), define \\(n \\times n\\) extended diagonal weight matrix \\(Z^k_n\\) first \\(k\\) diagonal entries equal 1 last \\(n-k\\) diagonal entries equal \\((x_{+k} - x_i) / k\\), \\(= 1,\\ldots,n-k\\). \\(k\\)th order falling factorial basis matrix given recursion: $$   \\begin{aligned}   H^0_n &= L_n, \\\\   H^k_n &= H^{k-1}_n Z^k_n   \\left[\\begin{array}{cc}   I_k & 0 \\\\   0 & L_{n-k}   \\end{array}\\right],   \\quad \\text{$k \\geq 1$},   \\end{aligned}   $$ \\(I_k\\) denotes \\(k \\times k\\) identity matrix, \\(L_{n-k}\\) denotes \\((n-k) \\times (n-k)\\) lower triangular matrix 1s.  details recursive representation, see Sections 3.3 6.3 Tibshirani (2020). option di_weighting = TRUE returns \\(H^k_n Z^{k+1}_n\\) \\(Z^{k+1}_n\\) \\(n \\times n\\) diagonal matrix defined . connected discrete integration explained help file h_mat_mult(). See also Section 3.3 Tibshirani (2020) details. basis function \\(h^k_j\\), \\(j \\geq k+2\\), single knot \\(x_{j-1}\\). falling factorial basis thus spans \\(k\\)th degree piecewise polynomials—discrete splines, fact—knots \\(x_{(k+1):(n-1)}\\). dimension space \\(n-k-1\\) (number knots) \\(+\\) \\(k+1\\) (polynomial dimension) \\(=\\) \\(n\\). Setting argument col_idx appropriately allow one form basis matrix discrete spline space corresponding arbitrary knot set \\(T   \\subseteq x_{(k+1):(n-1)}\\). information, see Sections 4.1 8 Tibshirani (2020). Note 1: computing least squares projection onto discrete spline space defined arbitrary knot set \\(T \\subseteq x_{(k+1):(n-1)}\\), one use falling factorial basis, instead use discrete natural spline basis n_mat(), latter much better numerical properties general. help file dspline_solve() gives information. Note 2: multiplication given vector \\(H^k_n\\), one form \\(H^k_n\\) current function carry multiplication, instead use h_mat_mult(), latter much efficient (quadratic-time versus linear-time).","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Construct H matrix — h_mat","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 6.3.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/h_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct H matrix — h_mat","text":"","code":"h_mat(2, 1:10) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                                #>  [1,] 1 .  .  .  .  .  . . . . #>  [2,] 1 1  .  .  .  .  . . . . #>  [3,] 1 2  1  .  .  .  . . . . #>  [4,] 1 3  3  1  .  .  . . . . #>  [5,] 1 4  6  3  1  .  . . . . #>  [6,] 1 5 10  6  3  1  . . . . #>  [7,] 1 6 15 10  6  3  1 . . . #>  [8,] 1 7 21 15 10  6  3 1 . . #>  [9,] 1 8 28 21 15 10  6 3 1 . #> [10,] 1 9 36 28 21 15 10 6 3 1 h_mat(2, 1:10 / 5) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                                                     #>  [1,] 1 .   .    .    .    .    .    .    .    .    #>  [2,] 1 0.2 .    .    .    .    .    .    .    .    #>  [3,] 1 0.4 0.04 .    .    .    .    .    .    .    #>  [4,] 1 0.6 0.12 0.04 .    .    .    .    .    .    #>  [5,] 1 0.8 0.24 0.12 0.04 .    .    .    .    .    #>  [6,] 1 1.0 0.40 0.24 0.12 0.04 .    .    .    .    #>  [7,] 1 1.2 0.60 0.40 0.24 0.12 0.04 .    .    .    #>  [8,] 1 1.4 0.84 0.60 0.40 0.24 0.12 0.04 .    .    #>  [9,] 1 1.6 1.12 0.84 0.60 0.40 0.24 0.12 0.04 .    #> [10,] 1 1.8 1.44 1.12 0.84 0.60 0.40 0.24 0.12 0.04 h_mat(2, 1:10 / 5, TRUE) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                                                            #>  [1,] 1 .   .    .     .     .     .     .     .     .     #>  [2,] 1 0.2 .    .     .     .     .     .     .     .     #>  [3,] 1 0.4 0.04 .     .     .     .     .     .     .     #>  [4,] 1 0.6 0.12 0.008 .     .     .     .     .     .     #>  [5,] 1 0.8 0.24 0.024 0.008 .     .     .     .     .     #>  [6,] 1 1.0 0.40 0.048 0.024 0.008 .     .     .     .     #>  [7,] 1 1.2 0.60 0.080 0.048 0.024 0.008 .     .     .     #>  [8,] 1 1.4 0.84 0.120 0.080 0.048 0.024 0.008 .     .     #>  [9,] 1 1.6 1.12 0.168 0.120 0.080 0.048 0.024 0.008 .     #> [10,] 1 1.8 1.44 0.224 0.168 0.120 0.080 0.048 0.024 0.008 h_mat(2, 1:10, col_idx = 2:5) #> 10 x 4 sparse Matrix of class \"dgCMatrix\" #>                  #>  [1,] .  .  .  . #>  [2,] 1  .  .  . #>  [3,] 2  1  .  . #>  [4,] 3  3  1  . #>  [5,] 4  6  3  1 #>  [6,] 5 10  6  3 #>  [7,] 6 15 10  6 #>  [8,] 7 21 15 10 #>  [9,] 8 28 21 15 #> [10,] 9 36 28 21"},{"path":"https://glmgen.github.io/dspline/reference/h_mat_mult.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiply by H matrix — h_mat_mult","title":"Multiply by H matrix — h_mat_mult","text":"Multiplies given vector H, falling factorial basis matrix given order, respect given design points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_mat_mult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiply by H matrix — h_mat_mult","text":"","code":"h_mat_mult(v, k, xd, di_weighting = FALSE, transpose = FALSE, inverse = FALSE)"},{"path":"https://glmgen.github.io/dspline/reference/h_mat_mult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiply by H matrix — h_mat_mult","text":"v Vector multiplied H, falling factorial basis matrix. k Order falling factorial basis matrix. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. di_weighting \"discrete integration weighting\" used? Multiplication weighted H gives discrete integrals design points; see details information. default FALSE. transpose Multiply transpose H? default FALSE. inverse Multiply inverse H? default FALSE.","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_mat_mult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiply by H matrix — h_mat_mult","text":"Product falling factorial basis matrix H input vector v.","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_mat_mult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multiply by H matrix — h_mat_mult","text":"falling factorial basis matrix order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(H^k_n\\). entries defined : $$   (H^k_n)_{ij} = h^k_j(x_i),   $$ \\(h^k_j\\) \\(j\\)th falling factorial basis function, defined help file h_mat(). matrix \\(H^k_n\\) can constructed recursively product \\(H^{k-1}_n\\) diagonally-weighted cumulative sum matrix; see help file h_mat(), Section 6.3 Tibshirani (2020). Therefore, multiplication \\(H^k_n\\) transpose can performed \\(O(nk)\\) operations based iterated weighted cumulative sums. See Appendix D Tibshirani (2020) details. option di_weighting = TRUE performs multiplication \\(H^k_n   Z^{k+1}_n\\) \\(Z^{k+1}_n\\) \\(n \\times n\\) diagonal matrix whose first \\(k+1\\) diagonal entries \\(Z^{k+1}_n\\) 1 last \\(n-k-1\\) diagonal entries \\((x_{+k+1} - x_i) / (k+1)\\), \\(=   1,\\ldots,n-k-1\\). connection discrete integration follows: multiplication \\(v = f(x_{1:n})\\) \\(H^k_n Z^{k+1}_n\\) gives order \\(k+1\\) discrete integrals (note increment order integration ) \\(f\\) points \\(x_{1:n}\\): $$   H^k_n Z^{k+1}_n v = (S^{k+1}_n f)(x_{1:n}).   $$ Lastly, matrix \\(H^k_n\\) special inverse relationship extended discrete derivative matrix \\(B^{k+1}_n\\) degree \\(k+1\\); satisfies: $$   H^k_n Z^{k+1}_n B^{k+1}_n = I_n,   $$ \\(Z^{k+1}_n\\) \\(n \\times n\\) diagonal matrix described , \\(I_n\\) \\(n \\times n\\) identity matrix. , combined fact extended discrete derivative matrix efficient recursive representation terms weighted differences, means multiplying \\((H^k_n)^{-1}\\) transpose can performed \\(O(nk)\\) operations. See Section 6.2 Appendix D Tibshirani (2020) details.","code":""},{"path":"https://glmgen.github.io/dspline/reference/h_mat_mult.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multiply by H matrix — h_mat_mult","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Section 6.2.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/h_mat_mult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiply by H matrix — h_mat_mult","text":"","code":"v <- sort(runif(10)) as.vector(h_mat(2, 1:10) %*% v) #>  [1]  0.1019510  0.3603773  1.1210679  2.9139575  6.4001239 12.2857066 #>  [7] 21.2824590 34.1866318 51.9416845 75.5160799 h_mat_mult(v, 2, 1:10) # more efficient #>  [1]  0.1019510  0.3603773  1.1210679  2.9139575  6.4001239 12.2857066 #>  [7] 21.2824590 34.1866318 51.9416845 75.5160799"},{"path":"https://glmgen.github.io/dspline/reference/n_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate N basis — n_eval","title":"Evaluate N basis — n_eval","text":"Evaluates discrete B-spline basis given order, respect given design points, evaluated arbitrary query points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/n_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate N basis — n_eval","text":"","code":"n_eval(k, xd, x, normalized = TRUE, knot_idx = NULL, N = NULL)"},{"path":"https://glmgen.github.io/dspline/reference/n_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate N basis — n_eval","text":"k Order discrete B-spline basis. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. x Query points. Must sorted increasing order. normalized discrete B-spline basis vectors normalized attain maximum value 1 design points? default TRUE. knot_idx Vector indices, subset (k+1):(n-1) n = length(xd), indicates design points used knot points discrete B-splines. Must sorted increasing order. default NULL, taken mean (k+1):(n-1). N Matrix discrete B-spline evaluations design points. default NULL, means precomputed constructing matrix discrete B-spline evaluations query points. N non-NULL, argument normalized ignored (used construct N design points).","code":""},{"path":"https://glmgen.github.io/dspline/reference/n_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate N basis — n_eval","text":"Sparse matrix dimension length(x) length(knot_idx) + k + 1.","code":""},{"path":"https://glmgen.github.io/dspline/reference/n_eval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate N basis — n_eval","text":"discrete B-spline basis functions order \\(k\\), defined respect design points \\(x_1 < \\ldots < x_n\\), denoted \\(\\eta^k_1, \\ldots, \\eta^k_n\\). discussion properties references, see help file n_mat(). current function produces matrix evaluations discrete B-spline basis arbitrary sequence query points. query point \\(x\\), matrix corresponding row entries: $$   \\eta^k_j(x), \\; j = 1, \\ldots, n.   $$ Unlike falling factorial basis, discrete B-spline basis generally available closed-form. Therefore, current function (unlike h_eval()) first check precompute evaluations discrete B-spline basis design points. argument N non-NULL, use matrix evaluations design points; N NULL, call n_mat() produce matrix, pass function arguments normalized knot_idx accordingly. obtaining matrix discrete B-spline evaluations design points, fast interpolation scheme dspline_interp() used produce evaluations query points.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/n_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate N basis — n_eval","text":"","code":"xd <- 1:9 / 10 x <- 1:8 / 10 + 0.05 n_mat(2, xd, knot_idx = c(3, 4, 7)) #> 9 x 6 sparse Matrix of class \"dgCMatrix\" #>                                                   #>  [1,] 1 . .         .         .         .         #>  [2,] . 1 .         .         .         .         #>  [3,] . . 1.0000000 .         .         .         #>  [4,] . . 0.5000000 0.7142857 .         .         #>  [5,] . . 0.1666667 1.0000000 0.1666667 .         #>  [6,] . . .         0.8571429 0.5000000 .         #>  [7,] . . .         0.2857143 1.0000000 .         #>  [8,] . . .         .         0.8333333 0.3333333 #>  [9,] . . .         .         .         1.0000000 n_eval(2, xd, x, knot_idx = c(3, 4, 7)) #> 8 x 6 sparse Matrix of class \"dgCMatrix\" #>                                                            #> [1,]  0.375  0.750 -0.12500000  .          .         .     #> [2,] -0.125  0.750  0.37500000  .          .         .     #> [3,]  .     -0.125  0.93750000  0.26785714 .         .     #> [4,]  .      .      0.31250000  0.91071429 0.0625000 .     #> [5,]  .      .      0.06250000  0.98214286 0.3125000 .     #> [6,]  .      .     -0.02083333  0.62500000 0.7291667 .     #> [7,]  .      .      .           0.10714286 1.0000000 0.125 #> [8,]  .      .      .          -0.03571429 0.5000000 0.625"},{"path":"https://glmgen.github.io/dspline/reference/n_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct N matrix — n_mat","title":"Construct N matrix — n_mat","text":"Constructs discrete B-spline basis matrix given order, respect given design points given knot points.","code":""},{"path":"https://glmgen.github.io/dspline/reference/n_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct N matrix — n_mat","text":"","code":"n_mat(k, xd, normalized = TRUE, knot_idx = NULL)"},{"path":"https://glmgen.github.io/dspline/reference/n_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct N matrix — n_mat","text":"k Order discrete B-spline basis matrix. Must >= 0. xd Design points. Must sorted increasing order, length least k+1. normalized discrete B-spline basis vectors normalized attain maximum value 1 design points? default TRUE. knot_idx Vector indices, subset (k+1):(n-1) n = length(xd), indicates design points used knot points discrete B-splines. Must sorted increasing order. default NULL, taken mean (k+1):(n-1) \"canonical\" discrete spline space (though case returned N matrix trivial: identity matrix). See details.","code":""},{"path":"https://glmgen.github.io/dspline/reference/n_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct N matrix — n_mat","text":"Sparse matrix dimension length(xd) length(knot_idx) + k + 1.","code":""},{"path":"https://glmgen.github.io/dspline/reference/n_mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct N matrix — n_mat","text":"discrete B-spline basis matrix order \\(k\\), respect design points \\(x_1 < \\ldots < x_n\\), knot set \\(T \\subseteq   x_{(k+1):(n-1)}\\) denoted \\(N^k_T\\). dimension \\((|T|+k+1)   \\times n\\), entries given : $$   (N^k_T)_{ij} = \\eta^k_j(x_i),   $$ \\(\\eta^k_1, \\ldots, \\eta^k_m\\) discrete B-spline (DB-spline) basis functions \\(m = |T|+k+1\\). suggested name, DB-spline functions linearly independent span space discrete splines knots \\(T\\). DB-spline \\(\\eta^k_j\\) key local support property: supported interval containing \\(k+2\\) adjacent knots. functions \\(\\eta^k_1, \\ldots, \\eta^k_m\\) , general, available closed-form, defined setting solving sequence locally-defined linear systems. knot set \\(T\\), computation evaluations DB-splines design points can done \\(O(nk^2)\\) operations; see Sections 7, 8.2, 8.3 Tibshirani (2020) details. current function uses sparse QR decomposition Eigen::SparseQR module C++ order solve local linear systems. \\(T = x_{(k+1):(n-1)}\\), knot set corresponding \"canonical\" discrete spline space (spanned falling factorial basis functions \\(h^k_1, \\ldots, h^k_n\\) whose evaluations make \\(H^k_n\\); see help file h_mat()), DB-spline basis matrix, denote \\(N^k_n\\), trivial: equals \\(n \\times n\\) identity matrix, \\(N^k_n = I_n\\). Therefore DB-splines really useful knot sets \\(T\\) proper subsets \\(x_{(k+1):(n-1)}\\). Specification knot set \\(T\\) done via argument knot_idx.","code":""},{"path":"https://glmgen.github.io/dspline/reference/n_mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Construct N matrix — n_mat","text":"Tibshirani (2020), \"Divided differences, falling factorials, discrete splines: Another look trend filtering related problems\", Sections 7, 8.2, 8.3.","code":""},{"path":[]},{"path":"https://glmgen.github.io/dspline/reference/n_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct N matrix — n_mat","text":"","code":"n_mat(2, 1:10, knot_idx = c(3, 4, 7)) #> 10 x 6 sparse Matrix of class \"dgCMatrix\" #>                                                   #>  [1,] 1 . .         .         .         .         #>  [2,] . 1 .         .         .         .         #>  [3,] . . 1.0000000 .         .         .         #>  [4,] . . 0.5000000 0.6923077 .         .         #>  [5,] . . 0.1666667 1.0000000 0.1538462 .         #>  [6,] . . .         0.9230769 0.4615385 .         #>  [7,] . . .         0.4615385 0.9230769 .         #>  [8,] . . .         0.1538462 1.0000000 0.1666667 #>  [9,] . . .         .         0.6923077 0.5000000 #> [10,] . . .         .         .         1.0000000 n_mat(2, 1:10, FALSE, knot_idx = c(3, 4, 7)) #> 10 x 6 sparse Matrix of class \"dgCMatrix\" #>                                                   #>  [1,] 1 . .         .         .         .         #>  [2,] . 1 .         .         .         .         #>  [3,] . . 1.0000000 .         .         .         #>  [4,] . . 0.5000000 1.0000000 .         .         #>  [5,] . . 0.1666667 1.4444444 0.1666667 .         #>  [6,] . . .         1.3333333 0.5000000 .         #>  [7,] . . .         0.6666667 1.0000000 .         #>  [8,] . . .         0.2222222 1.0833333 0.1666667 #>  [9,] . . .         .         0.7500000 0.5000000 #> [10,] . . .         .         .         1.0000000 n_mat(2, 1:10) #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                           #>  [1,] 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . #>  [4,] . . . 1 . . . . . . #>  [5,] . . . . 1 . . . . . #>  [6,] . . . . . 1 . . . . #>  [7,] . . . . . . 1 . . . #>  [8,] . . . . . . . 1 . . #>  [9,] . . . . . . . . 1 . #> [10,] . . . . . . . . . 1"},{"path":"https://glmgen.github.io/dspline/news/index.html","id":"dspline-102","dir":"Changelog","previous_headings":"","what":"dspline 1.0.2","title":"dspline 1.0.2","text":"Initial CRAN submission.","code":""}]
